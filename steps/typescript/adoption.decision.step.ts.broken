import { EventConfig, Handlers } from 'motia';
import { z } from 'zod';
import { TSStore } from './ts-store';

const WorkflowDecisionInputSchema = z.object({
  applicationId: z.string(),
  petId: z.string(),
  adopterName: z.string().optional(),
  adopterEmail: z.string().optional(),
  checkResult: z.string().optional(),
  checkDetails: z.string().optional(),
  summary: z.string().optional()
});

export const config: EventConfig<typeof WorkflowDecisionInputSchema> = {
  type: 'event',
  name: 'TsWorkflowDecision',
  description: 'Workflow gateway that decides to approve, reject, or escalate based on background check and summary',
  subscribes: ['ts.adoption.background.complete', 'ts.adoption.summary.complete'],
  emits: ['ts.adoption.approved', 'ts.adoption.rejected', 'ts.adoption.escalate'],
  input: WorkflowDecisionInputSchema,
  flows: ['typescript-adoptions'],
};

// Track completion of parallel processes per application
const applicationState = new Map<string, { backgroundComplete?: any, summaryComplete?: any }>();

export const handler: Handlers['TsWorkflowDecision'] = async (input, { emit, logger }) => {
  const { applicationId, petId, adopterName, adopterEmail } = input;

  logger.info('âš–ï¸ Processing workflow decision input', { 
    applicationId, 
    petId, 
    topic: input.topic || 'unknown',
    hasCheckResult: input.checkResult !== undefined,
    hasSummary: input.summary !== undefined,
    inputKeys: Object.keys(input)
  });

  try {
    // Determine which process completed based on event data
    const isBackgroundComplete = input.checkResult !== undefined;
    const isSummaryComplete = input.summary !== undefined;

    // Get or create application state
    let appState = applicationState.get(applicationId) || {};

    // Update state based on completed process
    if (isBackgroundComplete) {
      appState.backgroundComplete = {
        checkResult: input.checkResult,
        checkDetails: input.checkDetails,
        completedAt: new Date().toISOString()
      };
      logger.info('Background check completed for application', { applicationId });
    }

    if (isSummaryComplete) {
      appState.summaryComplete = {
        summary: input.summary,
        completedAt: new Date().toISOString()
      };
      logger.info('Summary generation completed for application', { applicationId });
    }

    // Save updated state
    applicationState.set(applicationId, appState);

    // Check if both processes are complete
    if (!appState.backgroundComplete || !appState.summaryComplete) {
      logger.info('Waiting for parallel processes to complete', { 
        applicationId,
        backgroundComplete: !!appState.backgroundComplete,
        summaryComplete: !!appState.summaryComplete,
        currentInput: {
          hasCheckResult: isBackgroundComplete,
          hasSummary: isSummaryComplete,
          checkResult: input.checkResult,
          summaryLength: input.summary?.length || 0
        }
      });
      return; // Wait for the other process
    }

    // Both processes complete - make decision
    logger.info('ðŸŽ¯ Making workflow decision - both processes complete', { applicationId, petId });

    const checkResult = appState.backgroundComplete.checkResult;
    const checkDetails = appState.backgroundComplete.checkDetails;
    const summary = appState.summaryComplete.summary;

    // Decision logic
    let decision = 'approve';
    let reason = 'Application meets all criteria';

    // Check for automatic rejection
    if (checkResult === 'failed') {
      decision = 'reject';
      reason = `Background check failed: ${checkDetails}`;
    } else if (checkResult === 'error') {
      decision = 'escalate';
      reason = 'Background check encountered errors, requires review';
    }

    // Check for escalation conditions
    if (decision === 'approve') {
      // Check for escalation triggers in summary
      if (summary && (
        summary.toLowerCase().includes('concern') ||
        summary.toLowerCase().includes('risk') ||
        summary.toLowerCase().includes('issue')
      )) {
        decision = 'escalate';
        reason = 'Summary indicates potential concerns requiring review';
      }

      // Check pet characteristics that might require escalation
      const pet = TSStore.get(petId);
      if (pet) {
        const petAge = Math.floor(pet.ageMonths / 12);
        if (petAge > 10) {
          decision = 'escalate';
          reason = 'Senior pet adoption requires additional assessment';
        }
        if (pet.species === 'bird' || pet.species === 'exotic') {
          decision = 'escalate';
          reason = 'Exotic pet adoption requires specialized assessment';
        }
      }
    }

    // Random escalation for demonstration (10% chance)
    if (decision === 'approve' && Math.random() < 0.1) {
      decision = 'escalate';
      reason = 'Random quality assurance review';
    }

    logger.info('Workflow decision made', { 
      applicationId, 
      petId, 
      decision, 
      reason,
      checkResult,
      summaryLength: summary?.length || 0
    });

    // Execute decision
    if (decision === 'approve') {
      // Mark pet as adopted
      const pet = TSStore.get(petId);
      if (pet) {
        TSStore.update(petId, { status: 'adopted' });
      }

      // Emit approval
      await emit({
        topic: 'ts.adoption.approved',
        data: {
          applicationId,
          petId,
          adopterName,
          adopterEmail,
          reason,
          checkResult,
          summary,
        }
      });

    } else if (decision === 'reject') {
      // Emit rejection
      await emit({
        topic: 'ts.adoption.rejected',
        data: {
          applicationId,
          petId,
          adopterName,
          adopterEmail,
          rejectionReason: reason,
          checkResult,
          checkDetails,
          summary,
        }
      });

    } else if (decision === 'escalate') {
      // Emit escalation for risk assessment
      await emit({
        topic: 'ts.adoption.escalate',
        data: {
          applicationId,
          petId,
          adopterName,
          adopterEmail,
          escalationReason: reason,
          checkResult,
          checkDetails,
          summary,
        }
      });
    }

    // Clean up application state
    applicationState.delete(applicationId);

  } catch (error) {
    logger.error('Workflow decision failed', { 
      applicationId, 
      petId, 
      error: error.message 
    });

    // Default to escalation on error
    await emit({
      topic: 'ts.adoption.escalate',
      data: {
        applicationId,
        petId,
        adopterName,
        adopterEmail,
        escalationReason: `Decision process error: ${error.message}`,
        error: error.message,
        traceId
      }
    });

    // Clean up
    applicationState.delete(applicationId);
  }
};
